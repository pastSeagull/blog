---
title: "部署"
date: 2022-05-21T23:30:21+08:00
draft: false
---

关于前端部署的一些知识点，`docker` & `docker-compose` & `node` & `nginx`，的一些尝试。
<!--more-->

先来创建一个单页应用，`create-react-app`。
这时候我们直接打包`yarn run build`，可以看到控制台给出的提示。
![avatar](https://raw.githubusercontent.com/pastSeagull/blog/main/img/build.png)
这时候我们执行`npx serve -s build`访问`IP:3000`可以看到打包好的效果了。

## Dockerfile
先在项目文件夹下新建两个文件。
`docker-compose.yaml` `simple.Dockerfile`

上面通过打包之后执行`npx serve -s build`
我们可以利用`Dockerfile`来简化这个这个步骤。
`simple.Dockerfile`
```dockerfile
FROM node:14-alpine

WORKDIR /code

ADD . /code
RUN yarn && npm run build

CMD npx serve -s build
EXPOSE 3000
```
`docker-compose.yaml`
```dockerfile
version: "3"
services:
  simple:
    build:
      context: .
      dockerfile: simple.Dockerfile
    ports:
      - 4000:80
```
执行命令`docker-compose up --build simple`

这里大部分时间都是在构建镜像和下载依赖包的过程，我们可以使用docker的缓存来加速build。
使用nginx来优化镜像的构建。

## 缓存和多阶段构建
可以利用`docker`缓存来加速build。[docker](https://docs.docker.com/get-started/09_image_best/)
![avatar](https://raw.githubusercontent.com/pastSeagull/blog/main/img/docker-build.png)

- 多阶段构建
> build打包好的dist文件夹里面其实都是静态文件，我们只需要node环境来帮我们打包即可。
> 之后静态文件我们只需要使用nginx对静态页面进行服务化即可

`simple.Dockerfile`修改如下
```dockerfile
FROM node:14-alpine as builder

WORKDIR /code

# 单独分离 package.json，是为了安装依赖可最大限度利用缓存
ADD package.json yarn.lock /code/
RUN yarn

ADD . /code
RUN npm run build

# 选择更小体积的基础镜像
FROM nginx:alpine
COPY --from=builder code/build /usr/share/nginx/html
```
这里算是前端部署优化的第一步吧
> 使用了docker的缓存来优化build的速度
> 多阶段构建，使用nginx来代替node镜像。

## 单页应用路由 & 强缓存
基础的八股文中的前端路由就不用多说了吧。让我们在项目中添加路由`yarn add react-router-dom`。并修改`App.js`。
`index.js`在用`<BrowserRouter>`来包裹一下。
![avatar](https://raw.githubusercontent.com/pastSeagull/blog/main/img/router-app.png)

这时候我们就得出了一个很简单页面。
> `/`首页
> 点击跳转`/about`

这时候我们点击跳转，路由是正常运行的，当我们通过`url`访问`IP:4000/about`的时候就404了。
我们需要配置一下`nginx`。
```editorconfig
location / {
    # 如果资源不存在，则回退到 index.html
    try_files  $uri $uri/ /index.html;  
}
```
这时候我们在访问就正常了。

- 强缓存 & 协商缓存。
> 缓存的话是分为强缓存和协商缓存的。这里用的是强缓存。
> 通过配置`Cache-Control`来设置资源的缓存时间。

我们进入打包好的dist文件夹里面，我们看到像js资源都是带有`hash`值的。如果我们修改了这类型的资源
hash值就会发生变化，旧的资源就不会进行访问了。
- 带有hash的资源我们设置强缓存。
- 没有的就设置不进行强缓存。

新建文件`nginx.conf` `router.Dockerfile`
router.Dockerfile
```dockerfile
FROM node:14-alpine as builder

WORKDIR /code

# 单独分离 package.json，是为了 yarn 可最大限度利用缓存
ADD package.json yarn.lock /code/
RUN yarn

# 单独分离 public/src，是为了避免 ADD . /code 时，因为 Readme/nginx.conf 的更改避免缓存生效
# 也是为了 npm run build 可最大限度利用缓存
ADD public /code/public
ADD src /code/src
RUN npm run build

# 选择更小体积的基础镜像
FROM nginx:alpine
ADD nginx.conf /etc/nginx/conf.d/default.conf
COPY --from=builder code/build /usr/share/nginx/html
```
nginx.conf
```editorconfig
server {
    listen       80;
    server_name  localhost;

    root   /usr/share/nginx/html;
    index  index.html index.htm;

    location / {
        # 解决单页应用服务端路由的问题
        try_files  $uri $uri/ /index.html;  

        # 非带 hash 的资源，需要配置 Cache-Control: no-cache，避免浏览器默认为强缓存
        expires -1;
    }

    location /static {
        # 带 hash 的资源，需要配置长期缓存
        expires 1y;
    }
}
```
修改`docker-compose.yaml`
```yaml
version: "3"
services:
  route:
    build:
      context: .
      dockerfile: router.Dockerfile
    ports:
      - 3000:80
  simple:
    build:
      context: .
      dockerfile: simple.Dockerfile
    ports:
      - 4000:80
```
到这里我们来运行一下`docker-compose up --build route`
![avatar](https://raw.githubusercontent.com/pastSeagull/blog/main/img/cache.png)

ok,看一下js文件，已经设置了强缓存了。其他不带有hash资源的设置成了`Cache-Control: no-cache`。

## 参考
___
1. [docker文档](https://docs.docker.com/get-started/)
2. [前端部署](https://q.shanyue.tech/deploy/#%E6%96%87%E5%AD%97%E4%B8%8E%E8%A7%86%E9%A2%91%E5%86%85%E5%AE%B9)
3. [前端docker快速入门——Compose](https://juejin.cn/post/7071667437384499237)
